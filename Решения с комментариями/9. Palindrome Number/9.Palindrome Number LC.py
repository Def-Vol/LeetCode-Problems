#https://leetcode.com/problems/palindrome-number/description/ - условие задачи
#Два решения - второе должно быть без преобразования в строку
import random

def mySolution(x=random.randint(-100, 1000000)):
    """
    :type x: int
    :rtype: bool
    """
    sx = str(x)
    return sx == sx[::-1]




'''
Для получения инвертированного числа без использования str() нужно делить
входящее значение на 10, сохраняя полученный остаток в новом значении, не
забывая добавлять разрядность при помощи умножения на 10.
'''
def mySolution_1(x=random.randint(-100, 1000000)):
    if x < 0:
        return False
    rem = divmod(x, 10)
    rx = 0
    while rem[1] or rem[0]:
        rx = (rx + rem[1])*10
        rem = divmod(rem[0], 10)
    rx /= 10
    return rx == x
'''
Недостаток этого решения, помимо лишних дествий, в том, что проверка
производится только в самом конце, когда палиндром получен целиком, тогда как
можно начинать проверку уже после получения первых двух чисел. Но поскольку
преобразование в строку недопустимо, то проверка уже по первым двум цифрам
потребует введения в алгоритм дополнительной накопительной переменной,
выполняющей роль счётчика, что увеличит О() алгоритма.

Решение будет легко найти, если вспомнить, что значение однозначно является
палиндромом, когда его вторая инвертированная половина равна первой
неинвертированной. Поэтому можно получать инвертированную половину, как бы
перемещая цифры с конца входящего значения в начало значения новой переменной.
По факту это будет выглядеть как в следующем решении:
'''
def mySolution_2(x=random.randint(-100, 1000000)):
    if x < 0:
        return False
    if x < 10:
        return True
    if x % 10 == 0:
        return False
    rx = x%10
    while x > rx:
        x //= 10
        rx = rx*10 + x%10
    if rx == x or (rx-x%1)/10 == x:
        return True
    else:
        return False





#Проверим, действительно ли последний алгоритм быстрее
def time_test():
    import timeit
    test = sum(timeit.repeat(mySolution, repeat=10, number=1000000))/10     #Измеряем миллион вызовов для существенного результата и из-за случайности величин входящих чисел
    test1 = sum(timeit.repeat(mySolution_1, repeat=10, number=1000000))/10
    test2 = sum(timeit.repeat(mySolution_2, repeat=10, number=1000000))/10
    print(f'Время выполнения с преобразованием: {test:.3f} секунд(-ы)')
    print(f'Время выполнения первого: {test1:.3f} секунд(-ы)')
    print(f'Время выполнения второго: {test2:.3f} секунд(-ы)')
    #Время выполнения с преобразованием: 0.208 секунд(-ы)
    #Время выполнения первого: 0.850 секунд(-ы)
    #Время выполнения второго: 0.525 секунд(-ы)
if __name__ == '__main__':
    time_test()
