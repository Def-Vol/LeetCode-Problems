#https://leetcode.com/problems/container-with-most-water/description/ - условие задачи


#Создадим список для теста на время исполнения:
from random import randint
test_list = []
for n in range(1000000):
    test_list.append(randint(1,3))
test_list = test_list*5


'''
Для решения задачи я решил обходить элементы списка по их значению, начиная с
большего. Для этого надо получить множество из входящего списка и отсортировать
элементы в порядке убывания. Поскольку элементы любого множества неупорядочены,
я преобразую его в список.

В самом цикле достаточно получить два индекса элементов по значению: ближайшего
к началу и ближайшего к концу (для второго использую инвертированную копию
списка). И остаётся получить результат, сохраняя больший.
'''
def mySolution_0(height):
    """
    :type height: List[int]
    :rtype: int
    """
    max_sort = list(set(height))
    max_sort.sort(reverse=True)
    rheight = height[:]
    rheight.reverse()
    i1, i2, result = len(height), 0, 0
    for mnum in max_sort:
        if height.index(mnum) < i1:
            i1 = height.index(mnum) 
        if len(height) - 1 - rheight.index(mnum) > i2:
            i2 = len(height) - 1 - rheight.index(mnum)
        if result < mnum*(i2-i1):
            result = mnum*(i2-i1)
    return result
'''
Это решение работает безотказно, но долго, так как перебирает даже те значения,
которые уже никак не могут превзойти результат. К тому в цикле повторяются
вычисления, которые можно было бы присвоить переменной и использовать её, вместо
повторного вычисления. Поэтому оптимизированный вариант этого решения будет
следующим:
'''
def mySolution(height=test_list):
    max_sort = list(set(height))
    max_sort.sort(reverse=True)
    rheight = height[:]
    rheight.reverse()
    i1, i2, result = len(height), 0, 0
    for mnum in max_sort:
        try:    
            if result/mnum < len(height)-1:     #Обходим элементы только до тех пор, пока их значение не настолько мало, что даже умножение его на максимальную разность индексов не способно будет превзойти результат
                mini = height.index(mnum)
                if mini < i1:
                    i1 = mini
                maxi = len(height) - 1 - rheight.index(mnum)
                if maxi > i2:
                    i2 = maxi
                maxr = mnum*(i2-i1)
                if result < maxr:
                    result = maxr
            else:
                return result
        except ZeroDivisionError:
            continue
    return result


'''
И хоть решение верное, сообщество предлагает куда более быстрый и простой
вариант:
'''

def comSolution(height=test_list):
    ans, i, j = 0, 0, len(height)-1
    while i < j:
        if height[i] <= height[j]:
            res = height[i] * (j - i)
            i += 1
        else:
            res = height[j] * (j - i)
            j -= 1
        if res > ans:
            ans = res
    return ans
'''
В сравнении с моим, это решение быстрее прежде всего из-за отсутствия инструкций
по созданию инвертированной копии списка и множества, что происходит в моём
решении на каждый из огромного количества тестов Leetcode, а потому занимает там
много времени. Во-вторых, тело цикла этого решения выполняет меньшее количество
операций за одну итерацию.

Однако при обработке особо большого списка, в котором несоизмеримо меньшее
количество уникальных значений (то есть очень много дубликатов), моё решение
может выполняться заметно быстрее. Проверим это:
'''
def time_test():
    import timeit
    test1 = timeit.timeit(mySolution, number=10)/10     #Измеряем 10 раз (для точности) 
    test2 = timeit.timeit(comSolution, number=10)/10
    print(f'Время выполнения первого составило {test1:.3f} секунд(-ы)')
    print(f'Время выполнения второго составило {test2:.3f} секунд(-ы)')
    #Для теста используем список с 5.000.000 элементами, имеющими всего одно из трёх значений
    #Время выполнения mySolution составило 0.064 секунд(-ы)
    #Время выполнения comSolution составило 0.560 секунд(-ы)
    '''
    Вывод: чем длиннее входящий список и чем меньше в нём уникальных значений,
    тем эффективнее моё решение в сравнении с решением сообщества.

    В связи с этим можно улучшить алгоритм всего решения, сделав его быстрее:
    если соотношение длины списка к количеству его уникальных значений
    достаточно велико, то использовать для решения алгоритм mySolution, если нет -
    comSolution. Однако такое решение будет эффективнее, только если среди
    входящих списков ожидаются такие длинные списки, иначе нет смысла грузить
    алгоритм дополнительной проверкой.
    '''
if __name__ == '__main__':
    time_test()
    
