#https://leetcode.com/problems/reverse-integer/description/ - условие задачи

'''
Для решения я сразу преобразую число в строку тут же применяя срез, указав
только отрицательную величину шага, что в результате инвертирует
последовательность символов в строке. Далее проверяю наличие минуса и
переставляю его в начало. Остаётся только преобразовать строку в целое число,
что само собой уберёт ведущие нули, если они есть.
'''
def mySolution(x = -2**29):
    """
    :type x: int
    :rtype: int
    """
    xs = str(x)[::-1]   
    if xs[-1] == '-':
        xs = '-' + xs[:-1]  
    xs = int(xs)    
    return xs if -2**31 <= xs <= 2**31-1 else 0



'''
В лучшем решении сообщества предлагается сохранить знак в переменной, вместо переставления его в строке:
'''
def comSolution(x = -2**29):
    sign = -1 if x < 0 else 1   
    xs = str(abs(x))[::-1]
    xs = int(xs) * sign
    return xs if -2**31 <= xs <= 2**31-1 else 0





#Сравним время выполнения разных решений
def time_test():  
    import timeit
    test1 = sum(timeit.repeat(mySolution, repeat=10, number=1000000))/10    #Измеряем 10 раз (для точности) время исполнения миллиона вызовов (чтобы время было существенным)
    test2 = sum(timeit.repeat(comSolution, repeat=10, number=1000000))/10
    print(f'Время выполнения первого составило {test1:.3f} секунд(-ы)')
    print(f'Время выполнения второго составило {test2:.3f} секунд(-ы)')
    #Для mySolution время выполнения составило 0.455 секунд(-ы)
    #Для comSolution время выполнения составило 0.390 секунд(-ы)
if __name__ == '__main__':
    time_test()

