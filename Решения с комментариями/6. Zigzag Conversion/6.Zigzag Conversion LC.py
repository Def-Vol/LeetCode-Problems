#https://leetcode.com/problems/zigzag-conversion/description/ - условие задачи
#Несмотря на то, что это код решения задачи, проверяемый алгоритмами в LeetCode, автор (Def Vol) спроектировать его как программу для конечного пользователя, добавляя с этой целью лишь циклы валидации.

#Концевые комментарии с цифрами в формате: ---[номер]* - слишком длинные, поэтому размещены после кода функции.

#Поиск этого решения был описан в отдельном файле "6.Поиск решения.txt" в этой папке
def mySolution(s = "R"*1000000, numRows = 100):
    """
    :type s: str
    :type numRows: int
    :rtype: str
    """
    while not isinstance(s, str):   #Отсеиваем плохие данные - для этого используем циклы валидации
        if isinstance(s, int) or isinstance(s, float):
            s = str(s)  #---1*
        else:
            s = input('Введите любой текст для преобразования: ')
    while not isinstance(numRows, int) or numRows < 1:
        try:
            numRows = int(input('Введите количество строк для шифрации(1 или более): '))    #---2*
        except ValueError:
            continue
    if numRows == 1 or len(s) <= numRows:   #Это все случаи, когда преобразование фактически не требуется и эффективно просто возвращать исходную строку
        return s
    elif numRows == 2:  #Для этого единственного случая создаём более эффективный код 
        subs1 = subs2 = ''
        for x in range(len(s)): 
            if x % 2:
                subs2 += s[x]
            else:
                subs1 += s[x]
        return subs1 + subs2
    else:   #И наконец главный код задачи, по которому и определяется сложность времени O() всего решения
        result = s[0]
        separ_max = 2*(numRows-1)  #---3*
        n = separ_max
        while n < len(s):   #Сначала конкатенируем сразу к результату символы первой подстроки шифра.
            result += s[n]
            n += separ_max    
        for n in range(1, numRows-1):   #Создаём и конкатенируем все остальные подстроки шифра, кроме последней
            subs = ''
            subs += s[n]
            separ1 = separ_max-2*n    #Создаём первый из двух шагов, так как подстроки шифра со второго до предпоследнего включительно формируются с использованием двух шагов  
            separ2 = separ_max - separ1    #Сумма двух шагов равна максимальному шагу 
            n = n + separ1    
            while n < len(s):   #Создаём саму подстроку шифра
                subs += s[n]
                if len(subs)%2 == 0:
                    n = n + separ2   #Если чёт, то следующий через шаг1, который легко вычисляется одним действием: разностью между максимальным и вторым шагом
                else:
                    n = n + separ1    
            result += subs
        n = numRows-1
        while n < len(s):   #Конкатенируем сразу к результату символы последней подстроки шифра   
            result += s[n]
            n += separ_max
        return result
'''
1.Для входящего строкового значения сначала выполняем попытку преобразования для
ситуаций, когда вместо текста вводится int или float значение, чтобы не
требовать от пользователя повторного ввода.

2.Для тех случаях, когда для numRows отправляется отрицательное значение, можно
было бы применить преобразование при помощи функции abs() (отправив в программу
таким образом противоположное по знаку значение), чтобы не требовать от
пользователя повторного ввода, но тогда он должен быть предупреждён о таком
преобразовании. Поскольку в рамках решения неизвестно, где размещать такое
предупреждение, корректнее будет и в этом случае требовать повторного ввода.

3.Вычисляем наибольший шаг, который нужно взять между символами входящей строки
s для первой и последней подстроки шифра. Остальные подстроки шифра используют
два чередующихся между собой шага, сумма которых как раз равна наибольшему
шагу. Именно поэтому первая и последняя подстроки создаются отдельными циклами.
'''


    


#Проверим, действительно ли алгоритм, используемый при numRows = 2, эффективнее основного алгоритма.
def time_test():
    import timeit
    test1 = timeit.timeit(mySolution, number=10) / 10 #Вычисляем среднее арифметическое из десяти измерений
    print(f'Время выполнения составило {test1:.3f} секунд(-ы)')
    '''
    s = "R"*1000000
    numRows = 2
    '''
    #Время выполнения составило 0.143 секунд(-ы)
    
    '''
    s = "R"*1000000
    numRows = 3
    '''
    #Время выполнения составило 0.192 секунд(-ы)

    '''
    s = "R"*1000000
    numRows = 100
    '''
    #Время выполнения составило 0.262 секунд(-ы)
if __name__ == '__main__':
    time_test()
