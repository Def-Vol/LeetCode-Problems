https://leetcode.com/problems/zigzag-conversion/description/ - условие задачи

Входящие данные: 
s - входящая строка, содержащая от 1 до 1000 символов включительно
numRows - количество строк (фактически количество подстрок), на которые надо зигзагом расстянуть s

Вывод:
result - та же строка s, но с изменённой последовательностью символов

Поиск решения:
Из условия ясно, что, в зависимости от указанного количества строк numRows, одна и та же строка s на выходе из программы будет содержать разную последовательность собственных символов. Для примера, в качестве строки s возьмём строку из условия задачи и любое значение numRows:

s = "PAYPALISHIRING"
numRows = 3
P   A   H   N
A P L S I I G   
Y   I   R
result = "PAHNAPLSIIGYIR" (результат читается по строкам слева-направо)

Чтобы лучше понять логику изменений, нужно заметить корреляции: взаимосвязи между полученными результатами, когда задают разное количество строк шифрации numRows. И, чтобы было легче, будем шифровать одну и ту же строку s - всё та же "PAYPALISHIRING". Итак, задавая разные numRows, зная как работает шифр из условия задачи, получим в итоге следующие результаты:

s = "PAYPALISHIRING"

numRows = 4
P     I     N
A   L S   I G
Y A   H R
P     I
result = "PINALSIGYAHRPI"

numRows = 5
P       H
A     S I
Y   I   R
P L     I G
A       N
result = "PHASIYIRPLIGAN"

numRows = 6
P         R
A       I I
Y     H   N
P   S     G
A I
L
result = "PRAIIYHNPSGAIL"

numRows = 7
P           N
A         I G
Y       R
P     I
A   H
L S
I
result = "PNAIGYRPIAHLSI"

Наша программа должна переставить символы входящей строки, а делать это придётся очевидно по индексу символов. Поэтому, чтобы было проще заметить корреляции, запишем эти результаты в виде последовательности индексов входящей строки (разделим их точкой, а когда начинаются индексы новой подстроки шифра, вместо точки поставим /):

numRows = 3
result = 0.4.8.12/1.3.5.7.9.11.13/2.6.10

numRows = 4
result = 0.6.12/1.5.7.11.13/2.4.8.10/3.9

numRows = 5
result = 0.8/1.7.9/2.6.10/3.5.11.13/4.12

numRows = 6
result = 0.10/1.9.11/2.8.12/3.7.13/4.6/5

numRows = 7
result = 0.12/1.11.13/2.10/3.9/4.8/5.7/6

Между результатами, представленными в таком виде, уже можно искать взаимосвязи, то есть отвечать на вопрос: какие сходства у этих результатов? Первое сходство так и бросается в глаза: каждая подстрока шифра, из которых состоит результат, начинается со следующего индекса (которая после /): первая подстрока - всегда с нуля, вторая - всегда с 1, третья - с 2 и так далее. И если это сходство ещё можно было увидеть, просто посмотрев на шифр, то следующие сходства становятся более ясны только сейчас: изменение разницы соседствующих индексов внутри одной подстроки. Выпишем эти разницы у каждого результата в том же формате:

numRows = 3
result - 4.4.4/2.2.2.2.2.2/4.4

numRows = 4
result - 6.6/4.2.4.2/2.4.2./6

numRows = 5
result - 8/6.2/4.4/2.6.2/8

numRows = 6
result - 10/8.2/6.4/4.6/2/

numRows = 7
result - 12/10.2/8/6/4/2/

Отсюда можно сделать следующие выводы (учитывая, что в некоторых вариантах просто не хватает длины строки):
- индексы первой и последней подстроки результата делают одинаковый шаг
- индексы остальных подстрок делают два чередующихся шага разной величины
- сумма двух этих разных шагов равна шагу в первой и последней подстроках
- шаги от начала до центра зеркальны шагам от центра до конца 

Так же мы видим, что наибольший шаг в результате зависит от значения numRows, а значит для его расчёта надо использовать эту переменную. Как можно увидеть выше, наибольший шаг всегда = numRows*2 - 2 = 2(numRows-1)

Корреляции обнаружены и их достаточно, чтобы сформировать решение. 

Поиск решения завершён.